#!/usr/bin/env python

import re
import os
import sys
import json
import time
import shlex
import inspect
import psutil
import signal
import argparse


CONFIGURATION_FILE = "/etc/intelmq/startup.conf"
PIDFILE = "/var/run/intelmq/%s.pid"


def print_bot_log(bot_id, message):
    print " %s bot %s." % (bot_id, message)
    
def print_bot_lognet(message):
    print "\n Botnet %s.\n" % (message)
    
       
def write_pidfile(bot_id, pid):
    filename = PIDFILE % bot_id
    with open(filename, 'w') as fp:
        fp.write(str(pid))

def remove_pidfile(bot_id):
    filename = PIDFILE % bot_id
    os.remove(filename)

def read_pidfile(bot_id):
    filename = PIDFILE % bot_id
    if check_pidfile(bot_id):
        with open(filename, 'r') as fp:
            pid = fp.read()
        return pid.strip()
    return None

def check_pidfile(bot_id):
    filename = PIDFILE % bot_id
    if os.path.isfile(filename):
        try:
            with open(filename, 'r') as fp:
                pid = fp.read()
            return int(pid.strip())
        except ValueError:
            return None
    return None
        
def start_process(bot_id, cmd):
    args = shlex.split(cmd)
    p = psutil.Popen(args)
    return p.pid

def stop_process(pid):
    p = psutil.Process(int(pid))
    p.send_signal(signal.SIGINT)
    
def status_process(pid):
    try:
        psutil.Process(int(pid))
        return True
    except psutil.NoSuchProcess:
        return False
    
    



class IntelMQContoller():
    
    def __init__(self):
        
        APPNAME = "intelmqctl"
        VERSION = "0.0.0"
        DESCRIPTION = "description: intelmqctl is the tool to control intelmq system"
        USAGE = '''
        intelmqctl --bot [start|stop|restart|status] --id=cymru-expert
        intelmqctl --botnet [start|stop|restart|status]
        intelmqctl --list [bots]'''
        
        parser = argparse.ArgumentParser(
                                        prog=APPNAME,
                                        usage=USAGE,
                                        epilog=DESCRIPTION
                                        )

        group = parser.add_mutually_exclusive_group()
        group_list = group.add_mutually_exclusive_group()
        
        parser.add_argument('-v', '--version', action='version', version=VERSION)
        parser.add_argument("--id", dest='bot_id', default=None, help='bot ID')
        
        group_list.add_argument('--bot',      choices=['start', 'stop', 'restart', 'status'], metavar='[start|stop|restart|status]', default=None)
        group_list.add_argument('--botnet',   choices=['start', 'stop', 'restart', 'status'], metavar='[start|stop|restart|status]', default=None)
        group_list.add_argument('--list',     choices=['bots'],                               metavar='[bots]'                     , default=None)

        self.args = parser.parse_args()
        
        if len(sys.argv) == 1:
            parser.print_help()
        
        if self.args.bot_id and not self.args.bot:
            print "usage: %s" % USAGE
            print "%s: error: argument --id: expected argument --bot [start|stop|restart|status]" % APPNAME
            exit()

        fp = open(CONFIGURATION_FILE, 'r')
        data = fp.read()
        self.info = json.loads(data)


    def auto_method_call(self, method):
        inspect_members = inspect.getmembers(self)
        for name, func in inspect_members:
            if name.startswith(method):
                return func        

    
    def run(self):
        if self.args.bot:
            method_name = "bot_" + self.args.bot
            call_method = self.auto_method_call(method_name)
            call_method(self.args.bot_id)
            
        elif self.args.botnet:
            method_name = "botnet_" + self.args.botnet
            call_method = self.auto_method_call(method_name)
            call_method()
            return
        elif self.args.list:
            method_name = "list_" + self.args.list
            call_method = self.auto_method_call(method_name)
            call_method()


    def bot_start(self, bot_id):        
        pid = read_pidfile(bot_id)
        if pid:
            if status_process(pid):
                print_bot_log(bot_id, "is already running")
                return
            else:
                remove_pidfile(bot_id)
        print_bot_log(bot_id, "is starting")
        self.__bot_start(bot_id, self.info[bot_id]['module'])

        
    def __bot_start(self, bot_id, module):
        cmd = "python -m %s %s" % (module, bot_id)
        pid = start_process(bot_id, cmd)
        write_pidfile(bot_id, pid)
        
        
    def bot_stop(self, bot_id):
        pid = read_pidfile(bot_id)
        if not pid:
            print_bot_log(bot_id, "is NOT running")
            return
        if not status_process(pid):
            remove_pidfile(bot_id)
            print_bot_log(bot_id, "is NOT running")
            return
        print_bot_log(bot_id, "is stopping")
        res = self.__bot_stop(bot_id, pid)
        time.sleep(1)
        if status_process(pid):
            print_bot_log(bot_id, "did NOT DIE")
        
    def __bot_stop(self, bot_id, pid):
        stop_process(pid)
        remove_pidfile(bot_id)    


    def bot_restart(self, bot_id):
        self.bot_stop(bot_id)
        self.bot_start(bot_id)
    
    
    def bot_status(self, bot_id):
        pid = read_pidfile(bot_id)
        if pid and status_process(pid):
            print_bot_log(bot_id, "is running")
            return
        print_bot_log(bot_id, "is NOT running")

    
    def botnet_start(self):
        print_bot_lognet("is starting")
        for bot_id in sorted(self.info.keys()):
            self.bot_start(bot_id)
        print_bot_lognet("started")    
    
    
    def botnet_stop(self):
        print_bot_lognet("is stopping")
        for bot_id in sorted(self.info.keys()):
            self.bot_stop(bot_id)
        print_bot_lognet("stopped")
    
    
    def botnet_restart(self):
        print_bot_lognet("is restarting")
        for bot_id in sorted(self.info.keys()):
            self.bot_stop(bot_id)
        print "\n\n"
        time.sleep(3)
        for bot_id in sorted(self.info.keys()):
            self.bot_start(bot_id)            
        print_bot_lognet("restarted")
    
    
    def botnet_status(self):
        for bot_id in sorted(self.info.keys()):
            self.bot_status(bot_id)

    
    def list_bots(self):
        title = "\n\nList of Bots:\n"
        title += "-" * (len(title)-1)
        title += "\n"
        print title
        for bot_id in sorted(self.info.keys()):
            print "Bot ID: %s\nDescription: %s\n" % (bot_id, self.info[bot_id]['description'])
            
    
if __name__ == "__main__":
    x = IntelMQContoller()
    x.run()
